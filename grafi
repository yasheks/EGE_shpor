N = 7
col = [i for i in range(N)]
f = open('11.txt')
W = []
for line in f:
    W.append(list(map(int, line.split())))

###

ostov = []  # список выбранных рёбер
for k in range(N - 1):#N это вершины, поэтоу берем n-1 для ребер
    minDist = float('inf')  # очень большое число
    iMin, jMin = -1, -1  # инициализируем индексы
    #тут мы просто начинаем наш первый цикл, где проходим по всем ребрам

###
    for i in range(N - 1):
        for j in range(i + 1, N):
            if col[i] != col[j] and W[i][j] != 0 and W[i][j] < minDist: #чекаем, что это не вершина, наша точка не равна нули, и что наша точка не больше минимума
                iMin = i
                jMin = j
                minDist = W[i][j]
                #здесь мы ищем самую минимальную вершину
###
    if iMin != -1 and jMin != -1:  # проверяем, что нашли рёбра
        ostov.append((iMin, jMin))  # добавляем выбранное ребро в список остова
        c = col[jMin]  # сохраняем цвет (метку) одной из вершин
        for i in range(N):
            if col[i] == c:  # обновляем метки для всех вершин, которые были соединены со jMin
                col[i] = col[iMin]  # присваиваем метку iMin всем связанным с jMin
    #записываем найденое ребро в наш новый "граф" который будет в ответе
###
for edge in ostov:
    print ( "(", edge[0], ",", edge[1], ")" )
#ну а тут уже выводим наше минимальное оставное дерево по индесам i и j

